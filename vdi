#!/cvmfs/software.eessi.io/versions/2023.06/compat/linux/x86_64/bin/bash

CMD_DIR=$(dirname "$(readlink -f "${BASH_SOURCE}")")
CMD_NAME=$(basename "${BASH_SOURCE}")

# make sure to use path to the command if it cannot be found using just the script's name
if command -v ${CMD_NAME} > /dev/null ; then
  CMD_USAGE_NAME=${CMD_NAME}
else
  CMD_USAGE_NAME=${BASH_SOURCE}
fi

usage() {
  echo "Usage: ${CMD_USAGE_NAME} [commands] [common arguments] [cmd specific arguments]"
  echo "  Commands:"
  echo "    run            - run the user program with the given user arguments"
  echo "  Common arguments:"
  echo "    -h             - print this usage information"
  echo "    -v             - verbose output"
  echo "    --dry-run      - only print what command would do without actually performing the actions"
  echo "  Arguments for command 'run':"
  echo "    program        - path to program to be run"
  echo "    program_args   - any arguments to the program to be run"
  exit 1
}

if [ "$#" -lt 1 ]; then
  usage
fi

# parse primary command
CMD=""
case "$1" in
  run) CMD="run"; shift ;;
  *) usage ;;
esac

# common arguments
VERBOSE=0
DRY_RUN=0
while [[ "$#" -gt 0 ]]; do
  case "$1" in
    -v) VERBOSE=1; shift ;;
    --dry-run) DRY_RUN=1; shift ;;
    *) break ;;
  esac
done

[[ ${VERBOSE} -eq 1 ]] && echo "remaining args: '${@}'"

# command specific arguments
while [[ "$#" -gt 0 ]]; do
  case "${CMD}" in
    run)
      # run the command (should be at least one more word because of the cond expr in while)
      [[ ${DRY_RUN} -eq 0 ]] && LD_PRELOAD=${CMD_DIR}/../lib64/libvdi.so "${@}" || echo "dry-run: run '${@}'"
      break
      ;;
  esac
done
